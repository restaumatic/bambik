module ViewModel where

import Prelude

import Data.Array (intercalate)
import Data.Lens (lens)
import Data.Maybe (Maybe(..), maybe)
import Effect.Class (class MonadEffect)
import Effect.Exception.Unsafe (unsafeThrow)
import Widget (Widget, WidgetOptics', constructor, field, iso)

type Order =
  { uniqueId :: UniqueId
  , shortId :: ShortId
  , customer :: NameInformal
  , payment :: Maybe Payment
  , fulfillment :: Fulfillment
  , total :: String
  }

type OrderConfirmation =
  { shortId :: ShortId }

type ShortId = String

type UniqueId = String

type NameInformal =
  { firstName :: String
  , lastName :: String
  }

type NameFormal =
  { forename :: String
  , surname :: String
  }

type Payment = { paid :: String }

data Fulfillment
  = DineIn { table :: Table }
  | Takeaway { time :: Time }
  | Delivery { address :: Address }

type Table = String

type Time = String

type Address = String

type OrderId = { short :: String, unique :: String}

-- could be generated by compiler

uniqueId = field @"uniqueId"

shortId = field @"shortId"

customer = field @"customer"

payment = field @"payment"

firstName = field @"firstName"

lastName = field @"lastName"

forename = field @"forename"

surname =  field @"surname"

fulfillment =  field @"fulfillment"

table =  field @"table"

time =  field @"time"

address =  field @"address"

unique = field @"unique"

short = field @"short"

total = field @"total"

paid = field @"paid"

dineIn :: WidgetOptics' { table :: Table } Fulfillment
dineIn = constructor "dineIn" DineIn case _ of
  DineIn c -> Just c
  _ -> Nothing

takeaway :: WidgetOptics' { time :: String } Fulfillment
takeaway = constructor "takeaway" Takeaway case _ of
  Takeaway c -> Just c
  _ -> Nothing

delivery :: WidgetOptics' { address :: Address } Fulfillment
delivery = constructor "delivery" Delivery case _ of
  Delivery c -> Just c
  _ -> Nothing

-- cannot be generated by compiler


formal :: WidgetOptics' NameFormal NameInformal
formal = iso "formal" toFormal toInformal
  where
    toFormal :: NameInformal -> NameFormal
    toFormal { firstName: forename, lastName: surname } = { forename, surname }
    toInformal :: NameFormal -> NameInformal
    toInformal { forename: firstName, surname: lastName } = { firstName, lastName }

data SubmitOrderRequest = SubmitOrderRequest { orderSerialized :: String }

data SubmitOrderResponse = SubmitOrderResponse { orderUniqueId :: String }

submitOrder :: forall m. MonadEffect m => Widget m Order Order
submitOrder = doSubmitOrder # lens (\order -> SubmitOrderRequest { orderSerialized: serializeOrder order}) (\order (SubmitOrderResponse { orderUniqueId }) -> order { uniqueId = orderUniqueId })
  where
    serializeOrder :: Order -> String
    serializeOrder order = intercalate "|" [order.uniqueId, order.shortId, order.customer.firstName, order.customer.lastName, order.total, maybe "not paid" (\{ paid } -> "paid " <> paid) order.payment, case order.fulfillment of
        (DineIn { table }) -> "dinein|" <> table
        (Takeaway { time }) -> "takeaway|" <> time
        (Delivery { address }) -> "delivery|\"" <> address <> "\""
      ]
    doSubmitOrder :: Widget m SubmitOrderRequest SubmitOrderResponse
    doSubmitOrder = unsafeThrow "!"
    -- doSubmitOrder = effect \_ -> do
    --   debug "processing request"
    --   delay $ Milliseconds 1000.0
    --   debug "request processed"
    --   pure $ SubmitOrderResponse { orderUniqueId: "1761562781" }

defaultOrder :: Order
defaultOrder =
  { uniqueId: "71287"
  , shortId: "7"
  , customer:
    { firstName: "David"
    , lastName: "Lynch"
    }
  , total: "12.30"
  , payment: Nothing
  , fulfillment: DineIn { table: "1" }
  }

