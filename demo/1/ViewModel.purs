module ViewModel
  ( Order
  , NameInformal
  , NameFormal
  , Payment
  , Fulfillment
  , Address
  , ShortId
  , UniqueId
  , uniqueId
  , shortId
  , customer
  , payment
  , short
  , unique
  , firstName
  , lastName
  , forename
  , surname
  , fulfillment
  , table
  , time
  , address
  , dineIn
  , takeaway
  , delivery
  , isDineIn
  , isTakeaway
  , isDelivery
  , formal
  , submitOrder
  , total
  , hasPayment
  , paid
  , defaultOrder
  ) where
  
import Prelude

import Data.Array (intercalate)
import Data.Lens (lens)
import Data.Maybe (Maybe(..), fromMaybe, maybe)
import Data.Profunctor (dimap)
import Effect.Aff (Aff, Milliseconds(..), delay)
import Effect.Class (class MonadEffect, liftEffect)
import Effect.Class.Console (debug)
import Effect.Console (log)
import Propagator (Propagator, effect)
import Propagator.Optics (Constructor, Iso, PropOptic, Lens, constructor, field, iso, iso')

type Order =
  { uniqueId :: UniqueId
  , shortId :: ShortId
  , customer :: NameInformal
  , payment :: Maybe Payment
  , fulfillment :: Fulfillment
  , total :: String
  }

type OrderConfirmation =
  { shortId :: ShortId }

type ShortId = String

type UniqueId = String

type NameInformal =
  { firstName :: String
  , lastName :: String
  }

type NameFormal =
  { forename :: String
  , surname :: String
  }

type Payment = { paid :: String }

data Fulfillment
  = DineIn { table :: Table }
  | Takeaway { time :: Time }
  | Delivery { address :: Address }

type Table = String

type Time = String

type Address = String

type OrderId = { short :: String, unique :: String}

-- could be generated by compiler

uniqueId = field @"uniqueId"

shortId = field @"shortId"

customer = field @"customer"

payment = field @"payment"

firstName = field @"firstName"

lastName = field @"lastName"

forename = field @"forename"

surname =  field @"surname"

fulfillment =  field @"fulfillment"

table =  field @"table"

time =  field @"time"

address =  field @"address"

unique = field @"unique"

short = field @"short"

total = field @"total"

paid = field @"paid"

dineIn :: Constructor { table :: Table } Fulfillment
dineIn = constructor "dineIn" DineIn case _ of
  DineIn c -> Just c
  _ -> Nothing

takeaway :: Constructor { time :: String } Fulfillment
takeaway = constructor "takeaway" Takeaway case _ of
  Takeaway c -> Just c
  _ -> Nothing

delivery :: Constructor { address :: Address } Fulfillment
delivery = constructor "delivery" Delivery case _ of
  Delivery c -> Just c
  _ -> Nothing

-- cannot be generated by compiler

isDineIn :: Iso (Maybe Fulfillment) Fulfillment
isDineIn = iso' (case _ of
  d@(DineIn _) -> Just d
  _ -> Nothing) (fromMaybe ( DineIn { table: "1"}))

isTakeaway :: Iso (Maybe Fulfillment) Fulfillment
isTakeaway = iso' (case _ of
  t@(Takeaway _) -> Just t
  _ -> Nothing) (fromMaybe (Takeaway { time: "15:30"}))

isDelivery :: Iso (Maybe Fulfillment) Fulfillment
isDelivery = iso' (case _ of
  d@(Delivery _) -> Just d
  _ -> Nothing) (fromMaybe (Delivery { address: "Mulholland Drive 2001, Los Angeles" }))

hasPayment :: PropOptic (Maybe Payment) (Maybe (Maybe Payment)) (Maybe Payment) (Maybe Payment)
hasPayment = dimap identity (map $ fromMaybe { paid: "0" })

formal :: Iso NameFormal NameInformal
formal = iso "formal" toFormal toInformal
  where
    toFormal :: NameInformal -> NameFormal
    toFormal { firstName: forename, lastName: surname } = { forename, surname }
    toInformal :: NameFormal -> NameInformal
    toInformal { forename: firstName, surname: lastName } = { firstName, lastName }

data SubmitOrderRequest = SubmitOrderRequest { orderSerialized :: String }

data SubmitOrderResponse = SubmitOrderResponse { orderUniqueId :: String }

submitOrder :: forall m. MonadEffect m => Propagator m Order Order
submitOrder = doSubmitOrder # lens (\order -> SubmitOrderRequest { orderSerialized: serializeOrder order}) (\order (SubmitOrderResponse { orderUniqueId }) -> order { uniqueId = orderUniqueId })
  where
    serializeOrder :: Order -> String
    serializeOrder order = intercalate "|" [order.uniqueId, order.shortId, order.customer.firstName, order.customer.lastName, order.total, maybe "not paid" (\{ paid } -> "paid " <> paid) order.payment, case order.fulfillment of
        (DineIn { table }) -> "dinein|" <> table
        (Takeaway { time }) -> "takeaway|" <> time
        (Delivery { address }) -> "delivery|\"" <> address <> "\""
      ]
    doSubmitOrder :: Propagator m SubmitOrderRequest SubmitOrderResponse
    doSubmitOrder = effect \_ -> do
      debug "processing request"
      delay $ Milliseconds 1000.0
      debug "request processed"
      pure $ SubmitOrderResponse { orderUniqueId: "1761562781" }

--

defaultOrder :: Order
defaultOrder =
  { uniqueId: "71287"
  , shortId: "7"
  , customer:
    { firstName: "David"
    , lastName: "Lynch"
    }
  , total: "12.30"
  , payment: Nothing
  , fulfillment: DineIn { table: "1" }
  }

