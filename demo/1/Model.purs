module Model where

import Prelude

import Data.Array (intercalate)
import Data.Generic.Rep (class Generic)
import Data.Lens (lens)
import Data.Maybe (Maybe(..), maybe)
import Data.Show.Generic (genericShow)
import Effect.Class (class MonadEffect, liftEffect)
import Effect.Console (log)
import Widget (Widget, WidgetOptics', constructor, effect, field, iso)

type Order =
  { uniqueId :: UniqueId
  , shortId :: ShortId
  , customer :: NameInformal
  , payment :: Maybe Payment
  , fulfillment :: Fulfillment
  , total :: String
  }

type OrderConfirmation =
  { shortId :: ShortId }

type ShortId = String

type UniqueId = String

type NameInformal =
  { firstName :: String
  , lastName :: String
  }

type NameFormal =
  { forename :: String
  , surname :: String
  }

type Payment = { paid :: String }

data Fulfillment
  = DineIn { table :: Table }
  | Takeaway { time :: Time }
  | Delivery { address :: Address }

type Table = String

type Time = String

type Address = String

type OrderId = { short :: String, unique :: String}

data SubmitOrderRequest = SubmitOrderRequest { orderSerialized :: String }

derive instance Generic SubmitOrderRequest _

instance Show SubmitOrderRequest where
  show = genericShow

data SubmitOrderResponse = SubmitOrderResponse { orderUniqueId :: String }

formal :: WidgetOptics' NameFormal NameInformal
formal = iso "formal" toFormal toInformal
  where
    toFormal :: NameInformal -> NameFormal
    toFormal { firstName: forename, lastName: surname } = { forename, surname }
    toInformal :: NameFormal -> NameInformal
    toInformal { forename: firstName, surname: lastName } = { firstName, lastName }

submitOrder :: forall m. MonadEffect m => Widget m Order Order
submitOrder = submitOrderEffect # lens (\order -> SubmitOrderRequest { orderSerialized: serializeOrder order}) (\order (SubmitOrderResponse { orderUniqueId }) -> order { uniqueId = orderUniqueId })
  where
    serializeOrder :: Order -> String
    serializeOrder order = intercalate "|" [order.uniqueId, order.shortId, order.customer.firstName, order.customer.lastName, order.total, maybe "not paid" (\{ paid } -> "paid " <> paid) order.payment, case order.fulfillment of
        (DineIn { table }) -> "dinein|" <> table
        (Takeaway { time }) -> "takeaway|" <> time
        (Delivery { address }) -> "delivery|\"" <> address <> "\""
      ]
    submitOrderEffect :: Widget m SubmitOrderRequest SubmitOrderResponse
    submitOrderEffect = effect \request -> do
      liftEffect $ log $ show request
      pure $ SubmitOrderResponse { orderUniqueId: "HAJ78" }

defaultOrder :: Order
defaultOrder =
  { uniqueId: "71287"
  , shortId: "7"
  , customer:
    { firstName: "David"
    , lastName: "Lynch"
    }
  , total: "12.30"
  , payment: Nothing
  , fulfillment: DineIn { table: "1" }
  }

-- could be generated by compiler

uniqueId = field @"uniqueId"

shortId = field @"shortId"

customer = field @"customer"

payment = field @"payment"

firstName = field @"firstName"

lastName = field @"lastName"

forename = field @"forename"

surname =  field @"surname"

fulfillment =  field @"fulfillment"

table =  field @"table"

time =  field @"time"

address =  field @"address"

unique = field @"unique"

short = field @"short"

total = field @"total"

paid = field @"paid"

dineIn :: WidgetOptics' { table :: Table } Fulfillment
dineIn = constructor "dineIn" DineIn case _ of
  DineIn c -> Just c
  _ -> Nothing

takeaway :: WidgetOptics' { time :: String } Fulfillment
takeaway = constructor "takeaway" Takeaway case _ of
  Takeaway c -> Just c
  _ -> Nothing

delivery :: WidgetOptics' { address :: Address } Fulfillment
delivery = constructor "delivery" Delivery case _ of
  Delivery c -> Just c
  _ -> Nothing
